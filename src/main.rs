use std::io::Error;
// use std::io::{BufRead, BufReader, Error, ErrorKind};
// use std::process::{Command, Stdio};

extern crate serde;
use serde::{Deserialize, Serialize};
use std::env;
use std::io::Read;
use std::io::Write;
use winapi::um::processthreadsapi;

#[derive(Serialize, Deserialize)]
struct Data {
    is_home: String,
    project: String,
    winrar: String,
    out: String,
}

#[derive(Debug)]
struct Param {
    compiler: String,
    rulfiles: String,
    libraries: String,
    linkpaths: String,
    includeifx: String,
    includeisrt: String,
    includescript: String,
    definitions: String,
    switches: String,
    builder: String,
    installproject: String,
    disk1: String,
}

fn path_exists(path: &str) -> bool {
    std::fs::metadata(path).is_ok()
}

fn gen_config(config: &str) -> std::result::Result<std::fs::File, std::io::Error> {
    println!("gen_config called");
    let data = Data {
        // Where to find InstallShield, it is a directory location, like:
        // "C:\\Program Files (x86)\\InstallShield\\2018"
        is_home: "C:\\Program Files (x86)\\InstallShield\\2018".to_owned(),
        project: "Your Project Name.ism".to_owned(),
        // Where to find WinRAR.exe
        winrar: "C:\\Program Files (x86)\\WinRAR\\WinRAR.exe".to_owned(),
        out: "out.exe".to_owned(),
    };
    let data = serde_json::to_string_pretty(&data);
    let mut file = std::fs::File::create(config).expect("create failed");
    file.write_all(data.unwrap().as_bytes())
        .expect("write failed");
    Ok(file)
}

fn get_param() -> std::io::Result<Param> {
    let cur_dir = env::current_exe()?;
    let path = std::path::Path::new(&cur_dir);
    let parent = path.parent().unwrap();
    let file_stem = path.file_stem().unwrap().to_str().unwrap();
    let config = format!("{}\\{}.json", parent.display(), file_stem);
    println!("{}", config);

    let mut file = std::fs::File::open(&config);
    match file {
        Err(e) => {
            println!("{}", e);
            gen_config(&config).unwrap();
        }
        _ => (),
    }

    file = std::fs::File::open(&config);
    let mut json_str = String::new();
    file.unwrap().read_to_string(&mut json_str).unwrap();
    let json: Data = serde_json::from_str(&json_str).unwrap();
    if !path_exists(json.is_home.as_str()) {
        panic!(
            "{} not exists, please edit {}.json",
            json.is_home, file_stem
        );
    }

    if !path_exists(json.winrar.as_str()) {
        panic!("{} not exists, please edit {}.json", json.winrar, file_stem);
    }

    let param = Param {
        compiler: format!("{}\\System\\Compile.exe", json.is_home),
        rulfiles: format!("{}\\Script Files\\Setup.rul", parent.display()),
        libraries: "\"isrt.obl\" \"ifx.obl\"".to_owned(),
        linkpaths: format!(
            "-LibPath\"{}\\Script\\Ifx\\Lib\" -LibPath\"{}\\Script\\Isrt\\Lib\"",
            json.is_home, json.is_home
        ),
        includeifx: format!("{}\\Script\\Ifx\\Include", json.is_home),
        includeisrt: format!("{}\\Script\\Isrt\\Include", json.is_home),
        includescript: format!("{}\\Script Files", parent.display()),
        definitions: "".to_owned(),
        switches: "-w50 -e50 -v3 -g".to_owned(),
        builder: format!("{}\\System\\ISCmdBld.exe", json.is_home),
        installproject: format!("{}\\{}", parent.display(), json.project),
        disk1: format!(
            "{}\\Media\\EIOSetup_SCH\\Disk Image\\Disk1",
            parent.display()
        ),
    };
    println!("{:?}", param);

    Ok(param)
}

fn to_wstring(value: &str) -> Vec<u16> {
    use std::os::windows::ffi::OsStrExt;

    std::ffi::OsStr::new(value)
        .encode_wide()
        .chain(std::iter::once(0))
        .collect()
}

// Error: The network name cannot be found, see:
// https://stackoverflow.com/questions/44757893/cmd-c-doesnt-work-in-rust-when-command-includes-spaces
fn run_cmd(command: &str) -> Result<(), Error> {
    println!("run: {}", command);
    /*let command_vec: Vec<String> = command.split_whitespace().map(str::to_string).collect();
    let stdout = Command::new("CMD")
        // first of all you should exec `chcp 65001`
        .arg("/C")
        .args(command_vec)
        .stdout(Stdio::piped())
        .spawn()?
        .stdout
        .ok_or_else(|| Error::new(ErrorKind::Other, "Could not capture standard output."))?;

    let reader = BufReader::new(stdout);
    reader
        .lines()
        .filter_map(|line| line.ok())
        .for_each(|line| println!("{}", line));*/

    unsafe {
        let mut pi = processthreadsapi::PROCESS_INFORMATION {
            hProcess: std::ptr::null_mut(),
            hThread: std::ptr::null_mut(),
            dwProcessId: 0 as _,
            dwThreadId: 0 as _,
        };

        let mut si = processthreadsapi::STARTUPINFOW {
            cb: std::mem::size_of::<processthreadsapi::STARTUPINFOW>() as _,
            lpReserved: std::ptr::null_mut(),
            lpDesktop: std::ptr::null_mut(),
            lpTitle: std::ptr::null_mut(),
            dwX: 0 as _,
            dwY: 0 as _,
            dwXSize: 0 as _,
            dwYSize: 0 as _,
            dwXCountChars: 0 as _,
            dwYCountChars: 0 as _,
            dwFillAttribute: 0 as _,
            dwFlags: 0 as _,
            wShowWindow: 0 as _,
            cbReserved2: 0 as _,
            lpReserved2: std::ptr::null_mut(),
            hStdInput: std::ptr::null_mut(),
            hStdOutput: std::ptr::null_mut(),
            hStdError: std::ptr::null_mut(),
        };

        let ret = processthreadsapi::CreateProcessW(
            std::ptr::null_mut(),
            to_wstring(command).as_mut_ptr(),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            winapi::shared::minwindef::FALSE,
            0,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            &mut si,
            &mut pi,
        );

        if ret == 0 {
            println!("error: {}", winapi::um::errhandlingapi::GetLastError());
        } else {
            println!("succeeded");
        }
    }

    Ok(())
}

fn build(param: Param) -> Result<(), Error> {
    // let chcp_cmd = "chcp 65001".to_owned();
    // run_cmd(chcp_cmd.as_str()).unwrap();
    let compile_cmd = format!(
        "\"{}\" \"{}\" {} {} -I\"{}\" -I\"{}\" -I\"{}\" {} {}",
        param.compiler.as_str(),
        param.rulfiles.as_str(),
        param.libraries.as_str(),
        param.linkpaths.as_str(),
        param.includeifx.as_str(),
        param.includeisrt.as_str(),
        param.includescript.as_str(),
        param.definitions.as_str(),
        param.switches.as_str()
    );
    run_cmd(compile_cmd.as_str()).unwrap();
    let build_cmd = format!(
        "\"{}\" -p \"{}\"",
        param.builder.as_str(),
        param.installproject.as_str()
    );
    run_cmd(build_cmd.as_str()).unwrap();

    Ok(())
}

fn main() {
    let param = get_param().unwrap();
    build(param).unwrap();
}
